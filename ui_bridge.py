from typing import Protocol, List, Dict, Any, Optional
from pathlib import Path

class AppUIBridge(Protocol):
    def show_message(self, level: str, title: str, message: str) -> None: ...
    def update_status_bar(self, message: str, timeout: int = 0) -> None: ...
    
    def clear_console_log(self) -> None: ...
    def update_console_log(self, text: str) -> None: ...
    
    def show_home_page(self) -> None: ...
    def show_composer_page(self) -> None: ...
    def show_console_page(self) -> None: ...
    
    def populate_composer_table(self, rows: List[List[str]]) -> None: ...
    
    def display_benchmark_summary_in_console(self, result: Dict[str, Any], run_id: Optional[Any]) -> None: ...
    def display_full_benchmark_details_in_console(self, details: Dict[str, Any]) -> None: ...
    
    def get_csv_file_path_via_dialog(self) -> Optional[Path]: ...
    # def get_pdf_file_path_via_dialog(self, start_dir: str) -> Optional[Path]: ... # This is UI internal for now

    # --- Methods for active benchmark updates ---
    def notify_active_benchmarks_updated(self, active_benchmarks_data: Dict[Any, Dict[str, Any]]) -> None: ...
    # Optional: If HomePage refresh is explicitly triggered by AppLogic via bridge
    # def refresh_home_page_view(self) -> None: ... 

    # Methods for AppLogic to get data from the UI, if it needs to pull them.
    # These are used by main_qt.py to provide data to AppLogic, rather than AppLogic pulling.
    # So, not strictly needed on the bridge *for AppLogic to call*, but the bridge *implementation* uses them.
    # For a cleaner AppLogic interface, AppLogic would not call these. Data would be pushed to AppLogic.
    # def get_composer_prompts(self) -> List[Dict[str, str]]: ...
    # def get_selected_pdf(self) -> Optional[Path]: ...

    # Method to start the UI event loop, if the bridge itself is responsible.
    # Or this is handled externally by the script that sets up the bridge.
    # def run_ui(self) -> int: ... 