from typing import Protocol, List, Dict, Any, Optional
from pathlib import Path

from typing import Protocol, Dict, List, Any, Optional, Callable, Tuple
from enum import Enum, auto

class DataChangeType(Enum):
    """Types of data changes that can trigger UI updates"""
    ACTIVE_BENCHMARKS = auto()
    BENCHMARK_PROGRESS = auto()
    BENCHMARK_COMPLETED = auto()
    BENCHMARK_LIST = auto()
    BENCHMARK_DELETED = auto()  # Added for delete notifications
    BENCHMARK_DETAILS = auto()  # Added for real-time benchmark detail updates
    COMPOSER_DATA = auto()
    VECTOR_STORES = auto()  # Added for vector store updates
    VECTOR_STORE_FILES = auto()  # Added for vector store file updates

class AppUIBridge(Protocol):
    """Protocol defining the interface between app logic and UI.
    The UI implementation must handle all these methods appropriately."""
    
    # Event handler properties for UI to call application logic
    on_new_benchmark_requested: Callable[[], None] = None
    on_open_csv_requested: Callable[[], None] = None
    on_run_benchmark_requested: Callable[[List[Dict[str, str]], Path, List[str]], None] = None
    on_show_home_requested: Callable[[], None] = None
    on_benchmark_selected: Callable[[int], None] = None
    on_export_benchmark_csv_requested: Callable[[int], None] = None  # New handler for CSV export
    
    # Core UI operations
    def show_message(self, level: str, title: str, message: str) -> None: ...
    def update_status_bar(self, message: str, timeout: int = 0) -> None: ...
    
    # Console operations
    def clear_console_log(self) -> None: ...
    def update_console_log(self, text: str) -> None: ...
    
    # Navigation
    def show_home_page(self) -> None: ...
    def show_composer_page(self) -> None: ...
    def show_console_page(self) -> None: ...
    
    # Data population
    def populate_composer_table(self, rows: List[List[str]]) -> None: ...
    def display_benchmark_summary_in_console(self, result: Dict[str, Any], run_id: Optional[Any]) -> None: ...
    def display_full_benchmark_details_in_console(self, details: Dict[str, Any]) -> None: ...
    
    # New methods for automatic updates
    def start_auto_refresh(self, interval_ms: int = 1000) -> None: ...
    def stop_auto_refresh(self) -> None: ...
    
    # Observer pattern methods
    def register_data_callback(self, change_type: DataChangeType, callback: Callable[[Any], None]) -> None: ...
    def unregister_data_callback(self, change_type: DataChangeType, callback: Callable[[Any], None]) -> None: ...
    
    # Data refresh triggers
    def refresh_home_page_data(self) -> None: ...
    def refresh_composer_page_data(self) -> None: ...
    def refresh_console_page_data(self) -> None: ...
    
    # Notification methods
    def notify_data_change(self, change_type: DataChangeType, data: Any) -> None: ...
    def notify_active_benchmarks_updated(self, active_benchmarks_data: Dict[Any, Dict[str, Any]]) -> None: ...
    def notify_benchmark_progress(self, job_id: int, progress_data: Dict[str, Any]) -> None: ...
    def notify_benchmark_complete(self, job_id: int, result_summary: Dict[str, Any]) -> None: ...
    def display_full_benchmark_details_in_console(self, details: Dict[str, Any]) -> None: ...
    
    def get_csv_file_path_via_dialog(self) -> Optional[Path]: ...
    # def get_pdf_file_path_via_dialog(self, start_dir: str) -> Optional[Path]: ... # This is UI internal for now

    # --- Methods for active benchmark updates ---
    def notify_active_benchmarks_updated(self, active_benchmarks_data: Dict[Any, Dict[str, Any]]) -> None: ...
    # Optional: If HomePage refresh is explicitly triggered by AppLogic via bridge
    # def refresh_home_page_view(self) -> None: ... 

    # Methods for AppLogic to get data from the UI, if it needs to pull them.
    # These are used by main_qt.py to provide data to AppLogic, rather than AppLogic pulling.
    # So, not strictly needed on the bridge *for AppLogic to call*, but the bridge *implementation* uses them.
    # For a cleaner AppLogic interface, AppLogic would not call these. Data would be pushed to AppLogic.
    # def get_composer_prompts(self) -> List[Dict[str, str]]: ...
    # def get_selected_pdf(self) -> Optional[Path]: ...

    # Method to start the UI event loop, if the bridge itself is responsible.
    # Or this is handled externally by the script that sets up the bridge.
    # def run_ui(self) -> int: ... 

    # --- Method to populate home page benchmark table ---
    def populate_home_benchmarks_table(self, benchmarks_data: Optional[List[Tuple]] = None) -> None: ...

    # Method to start the UI event loop, if the bridge itself is responsible.